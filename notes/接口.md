# reflect.Value

reflect.Type 具体的类型信息：main.S

// New returns a Value representing a pointer to a new zero value
// for the specified type. That is, the returned Value's Type is PtrTo(typ).

返回一个指针，指向new zero value 空的值 给特殊的类型。

返回的也是一个指针

```go
func New(typ Type) Value {
   if typ == nil {
      panic("reflect: New(nil)")
   }
   t := typ.(*rtype)
   ptr := unsafe_New(t)
   fl := flag(Ptr)
   return Value{t.ptrTo(), ptr, fl}
}

// implemented in package runtime
func unsafe_New(*rtype) unsafe.Pointer


	// typ holds the type of the value represented by a Value.
	typ *rtype

	// Pointer-valued data or, if flagIndir is set, pointer to data.
	// Valid when either flagIndir is set or typ.pointers() is true.
	ptr unsafe.Pointer

```

分析一下接口怎么表示：

![image-20211009193117447](/home/yy/.config/Typora/typora-user-images/image-20211009193117447.png)

![image-20211009202342335](/home/yy/.config/Typora/typora-user-images/image-20211009202342335.png)

没有可导出的字段？？不太懂什么意思





# reflect  interface{}

​	Go implements reflection with the `reflect` package which provides types and methods for inspecting portions of the interface structure and even modifying values at runtime.

​	With this post I hope to illustrate **how parts of the interface structure relate to the reflect API** and  ultimately make using the reflect package more approachable!

​	a value, a method set, and the type of the stored value.

![image-20211010003654972](/home/yy/.config/Typora/typora-user-images/image-20211010003654972.png)

​	When a function accepts an interface as a parameter, passing a value to that function packs the value, method set, and type into the interface.



```go
func (s *Server) sendResponse(sending *sync.Mutex,h *codec.Header,body interface{},cod codec.Codec)


s.sendResponse(sending,req.h,req.replyv.Interface(),cod) //错误已经在这里处理过了
```

reflect.Value:  是个结构体

![image-20211010003908882](/home/yy/.config/Typora/typora-user-images/image-20211010003908882.png)



# Examining Interface Data At Runtime with the Reflect Package

​	Once a value is stored in an interface, you can use the `reflect` package to examine its parts. 

​	We can’t examine the **interface struct directly**; instead the reflect package maintains its own copies of the interface structure to which we do have access.

​	Even though we’re accessing the interface via reflect objects, there’s a direct correlation to the underlying interface.

​	The `reflect.Type` and `reflect.Value` types  provide methods to access portions of the interface.

提供了方法去接触interface的部分。

`	reflect.Type` focuses on exposing data about types and is therefore confined to the `_type` portion of the structure 

​	while `reflect.Value` has to combine **type information with the value** to allow programmers to examine and manipulate values and therefore has to peek into the `_type` as well as the `data`.

# reflect.Type

​	The `reflect.TypeOf()` function is used to extract type information for a value.  

​	Since its only parameter is **an empty interface**, the value passed to it gets assigned to an interface and therefore the type, methodset, and value become available.

​	`reflect.TypeOf()` returns a `reflect.Type` which has methods that allow you to example the value’s type.

​	Below are a few of the `Type` methods available and **their corresponding bits** of the interface that they return.

下面是一些Type的可用方法，他们对应的bits 



![image-20211010005102983](/home/yy/.config/Typora/typora-user-images/image-20211010005102983.png)



![image-20211010005250599](/home/yy/.config/Typora/typora-user-images/image-20211010005250599.png)



# reflect.Value

​	So far we’ve only talked about type information – fields, methods, etc. `reflect.Value` gives us information about the actual value stored by an interface.

​	Methods associated with `reflect.Value`s necessarily combine type information with the actual value.  

​	For example, in order to extract fields from a struct, the reflect package has to combine knowledge of the layout of the struct – particularly information about the fields and field offsets stored in the `_type` – with the actual value pointed to by the `*data` portion of the interface in order to properly decode the struct.

类型和值要紧密结合才行。

![image-20211010005553103](/home/yy/.config/Typora/typora-user-images/image-20211010005553103.png)



# 接口定律

接口三个要素：

value，method set，type of stored value

传递三个参数就是这样传递了

//reflect.Type

```go
req.argv = reflect.New(reflect.TypeOf(""))  
//reflect.Value 类型和值 现申请了一个Value然后传入禁区
//argv是指针类型没问题
//reflect.ValueOf() 到底value里面是指针还是其他的值，不一定 看inerface吧
if err = cod.ReadBody(req.argv.Interface());err != nil {
```



# C++如何实现反射机制

​	反射是指 **程序在运行时动态获取对象属性与方法的一种机制**，即编译器需要**将类型信息(属性类型与偏移地址以及成员函数的地址等信息)编译到程序文件中**，当程序运行时将这些信息加载到内存中去，做到运行时只根据对象的地址或引用就可以获取到对象的类型信息，从而利用这些信息达到修改或重建对象的目标。

编译程序需要将类型信息编译到程序文件中。

类型信息，编译到文件中去。

​	21世纪以前内存与带宽一直是非常昂贵的资源，编译器在生成可执行文件时要兼顾系统内存等硬件资源，为节省成本不会将类型信息加载到运行内存中去。网络传输也要考虑带宽与各节点的性能，往往需要各通讯节点间采用紧致、简单、高效的通讯协议，这期间编程世界是C/C++的天下，网络上传输的是C/C++语言中的结构体，把结构体当作通讯协议具有无需序列化与反序列化的优点，完美契合当时的软硬件环境。

# 静态类型 动态类型

![image-20211010100526275](/home/yy/.config/Typora/typora-user-images/image-20211010100526275.png)

```go
// runtime/runtime2.go
// 非空接口
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
 
// 非空接口的类型信息
type itab struct {
    inter  *interfacetype  // 接口定义的类型信息
    _type  *_type      // 接口实际指向值的类型信息
    link   *itab  
    bad    int32
    inhash int32
    fun    [1]uintptr   // 接口方法实现列表，即函数地址列表，按字典序排序
}

// runtime/type.go
// 非空接口类型，接口定义，包路径等。
type interfacetype struct {
   typ     _type
   pkgpath name
   mhdr    []imethod      // 接口方法声明列表，按字典序排序
}
// 接口的方法声明 
type imethod struct {
   name nameOff          // 方法名
   ityp typeOff                // 描述方法参数返回值等细节
}
```

